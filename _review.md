# 코드 리뷰

**파일**: week1/test_solution.py

안녕하세요! `two_sum` 알고리즘 풀이에 대한 건설적인 비판과 개선점을 분석해 드리겠습니다.

제공해주신 코드는 브루트 포스(Brute Force) 방식으로 "두 수의 합" 문제를 해결합니다. 문제의 요구사항을 정확히 이해하고 구현했습니다.

---

### 1. 시간/공간 복잡도 (Time/Space Complexity)

*   **시간 복잡도 (Time Complexity):** `O(N^2)`
    *   `nums` 리스트의 길이를 `N`이라고 할 때, 바깥쪽 `for` 루프는 `N`번 실행됩니다.
    *   안쪽 `for` 루프는 `i`의 값에 따라 `N-1`, `N-2`, ..., `1`번 실행됩니다.
    *   총 연산 횟수는 대략 `(N * (N-1)) / 2` 에 비례하며, 이는 `N^2`에 비례하므로 시간 복잡도는 `O(N^2)`입니다.
*   **공간 복잡도 (Space Complexity):** `O(1)`
    *   함수 내에서 `i`, `j`, `complement` 등 몇 개의 변수만 사용하며, 이들이 `nums` 리스트의 크기에 따라 추가적인 공간을 차지하지 않습니다.
    *   반환하는 `[i, j]` 리스트 또한 항상 2개의 요소를 가지므로 상수 공간입니다. 따라서 공간 복잡도는 `O(1)`입니다.

### 2. 논리 오류 (Logical Errors)

*   **논리 오류는 없습니다.**
*   `j`를 `i+1`부터 시작하도록 설정하여 동일한 요소를 두 번 사용하는 경우(예: `nums[0] + nums[0]`)를 방지하고, `(idx1, idx2)`와 `(idx2, idx1)`처럼 중복된 쌍을 검사하지 않도록 효율적으로 처리했습니다.
*   합이 `target`이 되는 첫 번째 쌍을 찾으면 즉시 해당 인덱스들을 반환하고, 모든 경우를 탐색했음에도 찾지 못하면 빈 리스트 `[]`를 반환하는 것도 논리적으로 올바릅니다.

### 3. 더 효율적인 방법 (More Efficient Methods)

현재 `O(N^2)`는 작은 `N`에 대해서는 괜찮지만, `N`이 커질수록 성능이 급격히 저하됩니다. 이 문제를 해결하는 표준적인 방식은 **해시 맵(Hash Map) 또는 딕셔너리(Dictionary)**를 사용하는 것입니다.

*   **해시 맵 (Dictionary) 사용:**
    *   **아이디어:** 리스트를 한 번만 순회하면서 각 숫자에 대해 `target - 현재 숫자` (보충값, complement)가 이전에 등장했었는지 확인합니다. 만약 보충값이 이전에 등장했다면, 현재 숫자와 함께 합이 `target`이 되는 쌍을 찾은 것입니다.
    *   **구현:**
        1.  숫자와 해당 숫자의 인덱스를 저장할 딕셔너리(`num_map = {}`)를 초기화합니다.
        2.  `nums` 리스트를 `enumerate`를 사용하여 인덱스와 함께 순회합니다.
        3.  각 숫자 `num`에 대해, `complement = target - num`을 계산합니다.
        4.  `complement`가 `num_map`에 있는지 확인합니다.
            *   **있다면:** `num_map[complement]` (이전에 저장된 보충값의 인덱스)와 현재 `i` (현재 숫자의 인덱스)를 반환합니다.
            *   **없다면:** 현재 숫자 `num`과 인덱스 `i`를 `num_map`에 저장합니다 (`num_map[num] = i`).
        5.  루프가 끝날 때까지 찾지 못했다면 빈 리스트를 반환합니다.
    *   **복잡도:**
        *   **시간 복잡도:** `O(N)` (리스트를 한 번만 순회하고, 딕셔너리 조회 및 삽입은 평균적으로 `O(1)`이기 때문).
        *   **공간 복잡도:** `O(N)` (최악의 경우, 모든 숫자를 딕셔너리에 저장해야 할 수 있기 때문).

*   **투 포인터 (Two Pointers) 사용 (제약 조건 있음):**
    *   **아이디어:** 리스트가 정렬되어 있다는 전제 하에 사용할 수 있는 방법입니다. 두 개의 포인터를 리스트의 양 끝에 두고, 합을 계산하여 `target`과 비교하며 포인터를 이동시킵니다.
    *   **제약:** 이 방법은 원래 배열의 인덱스를 반환해야 하는 "두 수의 합" 문제에는 바로 적용하기 어렵습니다. 배열을 정렬하면 원래 인덱스 정보가 손실되기 때문입니다. 만약 원본 배열의 인덱스 대신 *값*을 반환하거나, 정렬 전 `(값, 인덱스)` 쌍을 만들어 정렬해야 하는 추가적인 단계가 필요합니다. 일반적으로 `O(N)` 해시 맵 방식이 더 선호됩니다.

### 4. 놓친 엣지 케이스 (Missed Edge Cases)

제공해주신 브루트 포스 솔루션은 생각보다 많은 엣지 케이스를 잘 처리합니다.

*   **빈 리스트 (`nums = []`):**
    *   `len(nums)`가 0이므로 `range(len(nums))`는 아무것도 순회하지 않습니다.
    *   `return []`이 실행되어 올바르게 처리됩니다.
*   **한 개의 요소만 있는 리스트 (`nums = [5]`):**
    *   `i`는 0이 되지만, `range(i+1, len(nums))`는 `range(1, 1)`이 되어 내부 루프가 실행되지 않습니다.
    *   `return []`이 실행되어 올바르게 처리됩니다 (두 개의 숫자를 찾아야 하므로).
*   **해답이 없는 경우 (`nums = [1, 2, 3], target = 10`):**
    *   모든 조합을 탐색하지만 `if` 조건이 참이 되지 않습니다.
    *   `return []`이 실행되어 올바르게 처리됩니다.
*   **중복된 숫자 값으로 해답을 찾는 경우 (`nums = [3, 3], target = 6`):**
    *   `i=0, j=1`일 때 `nums[0] + nums[1]`이 6이 되어 `[0, 1]`이 반환됩니다. 올바르게 처리됩니다.
*   **음수 포함 (`nums = [-1, 2, 7, 11], target = 9`):**
    *   `nums = [-1, 2, 7, 11]`, `target = 9`.
    *   `i=0 (nums[0]=-1)`, `j=2 (nums[2]=7)`일 때 `(-1) + 7 = 6` (틀림).
    *   `i=0 (nums[0]=-1)`, `j=3 (nums[3]=11)`일 때 `(-1) + 11 = 10` (틀림).
    *   이 예시로는 찾지 못했네요. `nums = [-1, 10, 2, 7], target = 9` 라면, `i=0, j=1`일 때 `(-1) + 10 = 9`가 되어 `[0, 1]`을 반환할 것입니다. 음수도 잘 처리됩니다.

### 5. 코드 개선점 (Code Improvement Suggestions)

현재 코드는 브루트 포스 방식으로는 이미 깔끔하고 효율적으로 작성되었습니다. "개선"이라기보다는 "더 나은/표준적인" 해결책으로의 전환을 제안합니다.

1.  **더 효율적인 방법으로 리팩토링:** 위에 설명된 해시 맵(딕셔너리) 방식을 사용하여 `O(N)` 시간 복잡도로 개선하는 것이 가장 큰 개선점입니다.

    ```python
    def two_sum_optimized(nums: list[int], target: int) -> list[int]:
        """
        주어진 숫자 리스트에서 합이 target이 되는 두 숫자의 인덱스를 찾습니다.
        해시 맵을 사용하여 O(N) 시간 복잡도로 동작합니다.

        Args:
            nums: 숫자 리스트.
            target: 목표 합계.

        Returns:
            합이 target이 되는 두 숫자의 인덱스 리스트 (예: [idx1, idx2]),
            해당하는 쌍이 없으면 빈 리스트.
        """
        num_map = {}  # { 숫자: 인덱스 }
        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_map:
                # 보충값이 맵에 있으면, 해당 보충값의 인덱스와 현재 숫자의 인덱스를 반환
                return [num_map[complement], i]
            # 보충값이 없으면, 현재 숫자를 맵에 저장
            num_map[num] = i
        return []

    # 테스트
    print(two_sum_optimized([2, 7, 11, 15], 9)) # 출력: [0, 1]
    print(two_sum_optimized([3, 2, 4], 6))     # 출력: [1, 2]
    print(two_sum_optimized([3, 3], 6))        # 출력: [0, 1]
    print(two_sum_optimized([3, 2, 4], 10))    # 출력: []
    ```

2.  **Docstring 추가:** 함수가 무엇을 하는지, 어떤 인자를 받는지, 무엇을 반환하는지 등을 설명하는 docstring을 추가하면 코드의 가독성과 유지보수성이 크게 향상됩니다. (위의 `two_sum_optimized` 예시에 추가됨)

3.  **타입 힌트 (Type Hints) 사용:** Python 3.5부터 도입된 타입 힌트를 사용하면 함수 인자와 반환 값의 타입을 명시하여 코드의 명확성을 높이고 잠재적인 타입 관련 버그를 줄일 수 있습니다. (위의 `two_sum_optimized` 예시에 추가됨)

---

**결론적으로,** 당신의 원본 코드는 문제의 요구사항을 `O(N^2)` 방식으로 정확하고 논리적 오류 없이 구현했습니다. 그러나 대부분의 코딩 테스트나 실무 환경에서는 `O(N)` 시간 복잡도의 해시 맵 기반 솔루션이 선호되므로, 이 방법을 익혀두시는 것이 좋습니다.

좋은 시작입니다!