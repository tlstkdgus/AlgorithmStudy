# 최적화 분석

주어진 `two_sum` 알고리즘은 두 수의 합을 찾는 전형적인 문제로, 효율성을 크게 개선할 수 있습니다. 현재 코드를 분석하고 최적화하는 과정을 단계별로 설명하겠습니다.

---

### 초기 코드 분석

```python
# 두 수의 합 문제 풀이
def two_sum(nums, target):
    for i in range(len(nums)):
        for j in range(i+1, len(nums)): # j는 i+1부터 시작하여 중복 검사와 자기 자신을 제외
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

**시간 복잡도 (Time Complexity):**
*   첫 번째 `for` 루프는 `n`번 실행됩니다 (여기서 `n`은 `nums` 리스트의 길이).
*   두 번째 `for` 루프는 첫 번째 루프의 반복마다 평균적으로 `n/2`번 실행됩니다. (최악의 경우 약 `n`번 실행)
*   따라서 전체적으로 약 `n * n/2` 번의 연산이 발생합니다. 이는 **O(n^2)** 의 시간 복잡도를 가집니다. `n`이 커질수록 성능이 급격히 저하됩니다.

**공간 복잡도 (Space Complexity):**
*   `i`, `j`와 같은 몇 개의 변수만 사용하고, 입력 크기(`n`)에 비례하여 추가적인 자료구조를 생성하지 않습니다.
*   따라서 **O(1)** 의 공간 복잡도를 가집니다.

---

### 최적화 방법

이 문제의 핵심은 특정 `nums[i]`에 대해 `target - nums[i]` 값을 빠르게 찾는 것입니다.

#### 1. 시간 복잡도 개선 방법

**해시 맵 (Hash Map / Dictionary) 사용:**
각 숫자를 한 번만 순회하면서, 현재 숫자에 대한 "보수(complement)"(`target - 현재_숫자`)가 이전에 나타났었는지 확인하는 방법입니다.

1.  빈 해시 맵(Python에서는 딕셔너리)을 생성합니다. 이 맵은 `숫자 -> 인덱스`의 형태로 값을 저장할 것입니다.
2.  `nums` 리스트의 각 숫자 `num`과 해당 인덱스 `i`를 순회합니다.
3.  현재 `num`에 대한 보수 `complement = target - num`를 계산합니다.
4.  만약 `complement`가 이미 해시 맵에 있다면, 이는 `complement`를 인덱스 `num_map[complement]`에서 찾았다는 의미입니다. 따라서 `[num_map[complement], i]`를 반환하면 됩니다.
5.  `complement`가 해시 맵에 없다면, 현재 숫자 `num`과 그 인덱스 `i`를 해시 맵에 `num_map[num] = i` 형태로 추가합니다.
6.  모든 숫자를 순회했는데도 짝을 찾지 못했다면, 빈 리스트 `[]`를 반환합니다.

**시간 복잡도 분석 (해시 맵):**
*   리스트를 한 번만 순회합니다 (`n`번).
*   각 순회 단계에서:
    *   보수 계산: O(1)
    *   해시 맵 조회 (존재 여부 확인): 평균 O(1) (최악의 경우 O(n)이나 드뭅니다)
    *   해시 맵 삽입: 평균 O(1) (최악의 경우 O(n)이나 드뭅니다)
*   따라서 전체 시간 복잡도는 **평균 O(n)** 입니다. 이는 `O(n^2)`에 비해 훨씬 빠릅니다.

#### 2. 공간 복잡도 개선 방법

해시 맵을 사용하는 시간 복잡도 최적화는 공간 복잡도를 증가시킵니다.

**해시 맵 사용 시 공간 복잡도 (Space Complexity):**
*   해시 맵은 최악의 경우(`nums`의 모든 숫자가 보수가 되기 전에 맵에 추가되는 경우) `n`개의 항목을 저장할 수 있습니다.
*   따라서 공간 복잡도는 **O(n)** 입니다.

**공간 복잡도에 대한 고려:**
이 문제에서는 시간 복잡도 `O(n^2)`를 `O(n)`으로 개선하기 위해 `O(1)` 공간을 `O(n)` 공간으로 교환(trade-off)하는 것이 일반적이고 합리적인 선택입니다. `O(n)` 시간 복잡도와 `O(1)` 공간 복잡도를 동시에 달성하는 것은 이 문제에서 쉽지 않거나 불가능합니다 (원본 배열을 정렬하고 투 포인터를 사용할 경우 원본 인덱스를 추적하기 위해 추가 작업이 필요하거나 `(값, 인덱스)` 쌍을 저장해야 하므로 여전히 `O(n)` 공간이 필요할 수 있습니다).

#### 3. 가독성 개선

*   **변수명:** `i`, `j` 대신 `idx`, `num` 등으로 더 의미 있는 변수명을 사용하고, `num_map`과 같이 해시 맵의 목적을 명확히 하는 이름을 사용합니다.
*   **`enumerate` 사용:** 파이썬의 `enumerate` 함수를 사용하여 인덱스와 값을 동시에 효율적으로 가져올 수 있어 코드가 더 간결해집니다.

#### 4. 최종 최적화된 코드

```python
def two_sum_optimized(nums, target):
    # num_map: 숫자를 키로, 해당 숫자의 인덱스를 값으로 저장하는 딕셔너리 (해시 맵)
    num_map = {}

    # nums 리스트를 한 번만 순회합니다.
    for idx, num in enumerate(nums):
        # 현재 숫자에 대한 보수(complement)를 계산합니다.
        # 즉, target에서 현재 숫자를 빼면 짝이 되는 숫자가 무엇인지 찾습니다.
        complement = target - num

        # 보수가 이미 num_map에 있는지 확인합니다.
        # 이는 이전에 순회했던 숫자들 중에 현재 숫자의 짝이 될 수 있는 숫자가 있는지 확인하는 것입니다.
        if complement in num_map:
            # 보수가 num_map에 있다면, 짝을 찾은 것입니다.
            # num_map[complement]는 보수의 인덱스이고, idx는 현재 숫자의 인덱스입니다.
            return [num_map[complement], idx]
        
        # 보수를 찾지 못했다면, 현재 숫자를 num_map에 추가합니다.
        # 앞으로 나타날 숫자의 보수가 현재 숫자가 될 수 있기 때문입니다.
        num_map[num] = idx
    
    # 리스트를 모두 순회했는데도 짝을 찾지 못했다면 빈 리스트를 반환합니다.
    return []

# 테스트
print(two_sum_optimized([2, 7, 11, 15], 9)) # 출력: [0, 1]
print(two_sum_optimized([3, 2, 4], 6))     # 출력: [1, 2]
print(two_sum_optimized([3, 3], 6))        # 출력: [0, 1]
print(two_sum_optimized([1, 2, 3], 7))     # 출력: []
```

#### 5. 왜 이 방법이 최선인지 설명

1.  **최적의 시간 복잡도 달성 (O(n)):**
    *   이 문제에서 모든 숫자를 최소 한 번은 확인해야 하므로, `O(n)`보다 빠른 시간 복잡도는 불가능합니다. 해시 맵을 사용하면 평균적으로 모든 숫자를 한 번만 순회하여 짝을 찾을 수 있으므로, 이론적으로 달성 가능한 최적의 시간 복잡도를 이룹니다.

2.  **간단하고 직관적인 구현:**
    *   두 개의 중첩 루프 대신 단일 루프만 사용하며, 해시 맵의 `in` 연산과 조회/삽입 연산이 대부분의 경우 매우 빠르게 처리됩니다. 코드가 간결하고 이해하기 쉽습니다.

3.  **원본 인덱스 유지:**
    *   이 문제는 단순히 두 숫자의 값을 찾는 것이 아니라, 해당 숫자의 *인덱스*를 반환해야 합니다. 해시 맵에 `(숫자, 인덱스)` 쌍을 저장함으로써, 원본 배열을 정렬하여 인덱스를 잃어버릴 위험 없이 인덱스를 정확히 추적할 수 있습니다. (정렬 기반 접근 방식은 인덱스를 추적하기 위해 추가적인 복잡성을 수반합니다).

4.  **효율적인 공간-시간 트레이드오프:**
    *   `O(1)` 공간 복잡도를 유지하면서 `O(n)` 시간 복잡도를 달성하는 것은 이 문제의 제약 조건(원본 인덱스 반환)하에서는 매우 어렵거나 불가능합니다. `O(n)` 공간을 사용하여 `O(n)` 시간 복잡도를 달성하는 것은 대부분의 실제 시나리오에서 받아들여지는 효율적인 트레이드오프입니다.

따라서 해시 맵을 사용하는 방식은 `two_sum` 문제에서 시간 복잡도, 구현의 용이성, 그리고 문제의 요구사항(인덱스 반환)을 모두 고려했을 때 가장 효율적이고 실용적인 최적의 솔루션이라고 할 수 있습니다.
